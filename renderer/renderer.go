package renderer

type SamplesPerPixel uint32

const (
	// Renderer should automatically select the appropriate SPP value.
	AutoSamplesPerPixel SamplesPerPixel = iota
)

/*
type Renderer struct {
	// A lock for synchronizing access to the framebuffer.
	sync.Mutex

	// Renderer frame dims.
	frameW uint32
	frameH uint32

	// A block scheduler instance
	scheduler tracer.BlockScheduler

	// The scene to be rendered.
	scene *scene.Scene

	// A buffered channel for receiving block completions.
	tracerDoneChan chan uint32

	// A channel for receiving tracer errors.
	tracerErrChan chan error

	// This buffer contains the final composited frame. It is generated by
	// the contents of the accumulation buffer after applying tone-mapping
	// and gamma correction. It uses an image.RGBA as its backing store making it
	// easy to display on screen on export to any format supported by the image package.
	frameBuffer *image.RGBA

	// An accumulation buffer where each frame's output is blended with
	// the previous frames' output. This enables progressive scene rendering.
	accumBuffer []float32

	// Number of sequential frames rendered from the current camera location.
	// This value is used to calculate a blend weight for adding the
	// framebuffer contents into the accumulation buffer.
	frameCount uint32

	// The time it took to render last frame (in nanoseconds)
	lastFrameTime int64

	// The list of attached tracers
	tracers []tracer.Tracer

	// SPP estimate based on last frame stats.
	sppEstimate uint32

	// The exposure parameter controls tone-mapping
	Exposure float32
}

// Create a new renderer
func NewRenderer(frameW, frameH uint32, sc *scene.Scene) *Renderer {
	return &Renderer{
		frameW:         frameW,
		frameH:         frameH,
		scheduler:      tracer.NewPerfectScheduler(),
		tracerDoneChan: make(chan uint32, frameH),
		tracerErrChan:  make(chan error, 0),
		frameBuffer:    image.NewRGBA(image.Rect(0, 0, int(frameW), int(frameH))),
		accumBuffer:    make([]float32, frameW*frameH*4),
		frameCount:     0,
		tracers:        make([]tracer.Tracer, 0),
		scene:          sc,
		sppEstimate:    1,
		Exposure:       1,
	}
}

// Shutdown and cleanup renderer and all connected tracers. This function will
// block if a frame is currently being rendered.
func (r *Renderer) Close() {
	r.Lock()
	defer r.Unlock()

	for _, tr := range r.tracers {
		tr.Close()
	}
	r.tracers = make([]tracer.Tracer, 0)
}

// Add a tracer to the renderer's tracer pool.
func (r *Renderer) AddTracer(tr tracer.Tracer) error {
	err := tr.Setup(r.frameW, r.frameH, r.accumBuffer, r.frameBuffer.Pix)
	if err != nil {
		return err
	}

	// sync scene with tracer
	err = r.syncScene(tr)
	if err != nil {
		return err
	}

	// Lock renderer so we can add the new tracer to the pool
	r.Lock()
	defer r.Unlock()

	r.tracers = append(r.tracers, tr)
	return nil
}

// Synchronize scene changes with tracer and manually trigger a flush.
func (r *Renderer) syncScene(tr tracer.Tracer) error {
	tr.AppendChange(tracer.UpdateCamera, r.scene.Camera)
	tr.AppendChange(tracer.SetMaterials, r.scene.Materials)
	tr.AppendChange(tracer.SetBvhNodes, r.scene.BvhNodes)
	tr.AppendChange(tracer.SetPrimitivies, r.scene.Primitives)
	tr.AppendChange(tracer.SetEmissiveLightIndices, r.scene.EmissivePrimitiveIndices)

	return tr.ApplyPendingChanges()
}

// Render frame. This method splits the screen into blocks and distributes them
// to all available tracers. Once the blocks have been successfully rendered
// it composes the results into an RGBA image. Callers must never modify the
// returned RGBA image.
func (r *Renderer) Render(spp SamplesPerPixel) (*image.RGBA, error) {
	r.Lock()
	defer r.Unlock()

	startTime := time.Now()

	if r.scene == nil {
		return nil, ErrSceneNotDefined
	}
	if r.scene.Camera == nil {
		return nil, ErrCameraNotDefined
	}
	if len(r.tracers) == 0 {
		return nil, ErrNoTracers
	}

	// Update block assignments
	blockAssignment := r.scheduler.Schedule(r.tracers, r.frameH, r.lastFrameTime)

	// Setup common block request values
	var blockReq tracer.BlockRequest
	blockReq.FrameCount = r.frameCount + 1
	blockReq.DoneChan = r.tracerDoneChan
	blockReq.ErrChan = r.tracerErrChan
	if spp == AutoSamplesPerPixel {
		blockReq.SamplesPerPixel = r.sppEstimate
	} else {
		blockReq.SamplesPerPixel = uint32(spp)
	}
	blockReq.Exposure = r.Exposure
	blockReq.Seed = rand.Uint32()

	// Enqueue work units
	var pendingRows uint32 = 0
	for idx, tr := range r.tracers {
		blockReq.BlockY = pendingRows
		blockReq.BlockH = blockAssignment[idx]
		tr.Enqueue(blockReq)

		pendingRows += blockReq.BlockH
	}

	// Wait for all rows to be completed
	for {
		select {
		case completedRows := <-r.tracerDoneChan:
			pendingRows -= completedRows
			if pendingRows == 0 {
				r.frameCount++
				r.lastFrameTime = time.Since(startTime).Nanoseconds()
				return r.frameBuffer, nil
			}
		case err := <-r.tracerErrChan:
			return nil, err
		}
	}
}

// Sync all tracers with the updated camera position.
func (r *Renderer) UpdateCamera() {
	r.Lock()
	defer r.Unlock()

	// This is equivalent to clearing the accumulation buffer
	r.frameCount = 0

	for _, tr := range r.tracers {
		tr.AppendChange(tracer.UpdateCamera, r.scene.Camera)
	}
}*/
