package renderer

import (
	"fmt"
	"image"
	"math"
	"math/rand"
	"sync"
	"time"

	"github.com/achilleasa/go-pathtrace/scene"
	"github.com/achilleasa/go-pathtrace/tracer"
)

type SamplesPerPixel uint32

const (
	// Renderer should automatically select the appropriate SPP value.
	AutoSamplesPerPixel SamplesPerPixel = iota
)

type Renderer struct {
	// A lock for synchronizing access to the framebuffer.
	sync.Mutex

	// Renderer frame dims.
	frameW uint32
	frameH uint32

	// The scene to be rendered.
	scene *scene.Scene

	// A buffered channel for receiving block completions.
	tracerDoneChan chan uint32

	// A channel for receiving tracer errors.
	tracerErrChan chan error

	// This buffer contains the final composited frame. It is generated by
	// the contents of the accumulation buffer after applying tone-mapping
	// and gamma correction. It uses an image.RGBA as its backing store making it
	// easy to display on screen on export to any format supported by the image package.
	frameBuffer *image.RGBA

	// An accumulation buffer where each frame's output is blended with
	// the previous frames' output. This enables progressive scene rendering.
	accumBuffer []float32

	// Number of sequential frames rendered from the current camera location.
	// This value is used to calculate a blend weight for adding the
	// framebuffer contents into the accumulation buffer.
	frameCount uint32

	// A list of assigned block height for each tracer
	blockAssignment []uint32

	// The list of attached tracers
	tracers []tracer.Tracer

	// SPP estimate based on last frame stats.
	sppEstimate uint32
}

// Create a new renderer
func NewRenderer(frameW, frameH uint32, sc *scene.Scene) *Renderer {
	return &Renderer{
		frameW:          frameW,
		frameH:          frameH,
		tracerDoneChan:  make(chan uint32, frameH),
		tracerErrChan:   make(chan error, 0),
		frameBuffer:     image.NewRGBA(image.Rect(0, 0, int(frameW), int(frameH))),
		accumBuffer:     make([]float32, frameW*frameH*4),
		frameCount:      0,
		blockAssignment: make([]uint32, 0),
		tracers:         make([]tracer.Tracer, 0),
		scene:           sc,
		sppEstimate:     1,
	}
}

// Shutdown and cleanup renderer and all connected tracers. This function will
// block if a frame is currently being rendered.
func (r *Renderer) Close() {
	r.Lock()
	defer r.Unlock()

	for _, tr := range r.tracers {
		tr.Close()
	}
	r.tracers = make([]tracer.Tracer, 0)
}

// Add a tracer to the renderer's tracer pool.
func (r *Renderer) AddTracer(tr tracer.Tracer) error {
	err := tr.Setup(r.frameW, r.frameH, r.accumBuffer, r.frameBuffer.Pix)
	if err != nil {
		return err
	}

	// sync scene with tracer
	err = r.syncScene(tr)
	if err != nil {
		return err
	}

	// Lock renderer so we can add the new tracer to the pool
	r.Lock()
	defer r.Unlock()

	r.tracers = append(r.tracers, tr)
	r.blockAssignment = append(r.blockAssignment, 0)
	return nil
}

// Synchronize scene changes with tracer and manually trigger a flush.
func (r *Renderer) syncScene(tr tracer.Tracer) error {
	tr.AppendChange(tracer.UpdateCamera, r.scene.Camera)
	tr.AppendChange(tracer.SetMaterials, r.scene.Materials)
	tr.AppendChange(tracer.SetBvhNodes, r.scene.BvhNodes)
	tr.AppendChange(tracer.SetPrimitivies, r.scene.Primitives)
	tr.AppendChange(tracer.SetEmissiveLightIndices, r.scene.EmissivePrimitiveIndices)

	return tr.ApplyPendingChanges()
}

// Distribute the frame rows between the pooled tracers.
func (r *Renderer) assignTracerBlocks() {
	// Get speed estimate for each tracer and distribute rows accordingly
	var totalSpeedEstimate float32 = 0.0
	for _, tr := range r.tracers {
		totalSpeedEstimate += tr.SpeedEstimate()
	}
	scaler := float32(r.frameH) / totalSpeedEstimate

	for idx, tr := range r.tracers {
		r.blockAssignment[idx] = uint32(math.Ceil(float64(tr.SpeedEstimate() * scaler)))
	}
}

// Render frame. This method splits the screen into blocks and distributes them
// to all available tracers. Once the blocks have been successfully rendered
// it composes the results into an RGBA image. Callers must never modify the
// returned RGBA image.
func (r *Renderer) Render(spp SamplesPerPixel) (*image.RGBA, error) {
	r.Lock()
	defer r.Unlock()

	// Time frame
	start := time.Now()
	defer func() {
		fmt.Printf("Frame time: %d ms\n", time.Since(start).Nanoseconds()/1000000)
	}()

	if r.scene == nil {
		return nil, ErrSceneNotDefined
	}
	if r.scene.Camera == nil {
		return nil, ErrCameraNotDefined
	}
	if len(r.tracers) == 0 {
		return nil, ErrNoTracers
	}

	// Update block assignments
	r.assignTracerBlocks()

	// Setup common block request values
	var blockReq tracer.BlockRequest
	blockReq.FrameCount = r.frameCount + 1
	blockReq.DoneChan = r.tracerDoneChan
	blockReq.ErrChan = r.tracerErrChan
	if spp == AutoSamplesPerPixel {
		blockReq.SamplesPerPixel = r.sppEstimate
	} else {
		blockReq.SamplesPerPixel = uint32(spp)
	}
	blockReq.Exposure = r.scene.Camera.Exposure
	blockReq.Seed = rand.Uint32()

	// Enqueue work units
	var pendingRows uint32 = 0
	for idx, tr := range r.tracers {
		blockReq.BlockY = pendingRows
		blockReq.BlockH = r.blockAssignment[idx]
		if blockReq.BlockY+blockReq.BlockH > r.frameH {
			blockReq.BlockH = r.frameH - blockReq.BlockY
		}
		tr.Enqueue(blockReq)

		pendingRows += blockReq.BlockH
	}

	// Wait for all rows to be completed
	for {
		select {
		case completedRows := <-r.tracerDoneChan:
			pendingRows -= completedRows
			if pendingRows == 0 {
				r.frameCount++
				//r.updateAccumulationBuffer()
				return r.frameBuffer, nil
			}
		case err := <-r.tracerErrChan:
			return nil, err
		}
	}
}

// Sync all tracers with the updated camera position.
func (r *Renderer) UpdateCamera() {
	r.Lock()
	defer r.Unlock()

	// This is equivalent to clearing the accumulation buffer
	r.frameCount = 0

	for _, tr := range r.tracers {
		tr.AppendChange(tracer.UpdateCamera, r.scene.Camera)
	}
}
