// Global parameters that will be set via a template during compilation time.
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
#define FRAME_W 512
#define FRAME_H 512
#define TEXEL_STEP_X 1.0f / 512.0f
#define TEXEL_STEP_Y 1.0f / 512.0f

#define DEBUG (get_global_id(0)==0 && get_global_id(1)==0)

// Render options
#define COS_WEIGHTED_LIGHT_SAMPLING
//#define CONE_LIGHT_SAMPLING

// Limits
#define MAX_BOUNCES 4 // iris pro compilation runs out of memory if set to > 5
#define MIN_BOUNCES_TO_USE_RR 3

// Epsilon values
#define NUDGE_EPSILON 1.0e-3f
#define SNAP_EPSILON 1.0e-5f

// Vector helpers
#define VEC3_MAX_COMPONENT(v) max(v.x, max(v.y, v.z))
#define VEC1(x) (float4)(x, 0.0f, 0.0f, 0.0f)
#define VEC2(x,y) (float4)(x, y, 0.0f, 0.0f)
#define VEC3(x,y,z) (float4)(x,y,z,0.0f)
#define VEC4(x,y,z,w) (float4)(x,y,z,w)
#define ORIGIN(v) VEC3(v,v,v)

// Supported material types
#define MATERIAL_DIFFUSE 0.0f
#define MATERIAL_SPECULAR 1.0f
#define MATERIAL_REFRACTIVE 2.0f
#define MATERIAL_EMISSIVE 3.0f

// Supported primitive types
#define PRIMITIVE_PLANE 0
#define PRIMITIVE_SPHERE 1
#define PRIMITIVE_BOX 2
#define PRIMITIVE_TRIANGE 3

// Packed data sampler
const sampler_t dataSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;

// Data offset calculators. Buffers are stored as RGBA floats (16 bytes per pixel)
// - packed materials are 48 bytes long (3 pixels each)
// - packed primitives are 128 bytes long (8 pixels each)
#define MAT_OFFSET(itemIndex, field) (float)(itemIndex * 3 + field)
#define PRIM_OFFSET(itemIndex, field) (float)(itemIndex * 8 + field)

// -----------------------
// Object and material definitions
// The following code will be autogenerated by the scene processor
// ------------------
__constant float4 sceneBgColor = (float4)(0.0f);

// -----------------------
// Random number and direction generators
// -----------------------
float2 clRand(uint2 *state)
{
	const float2 invMaxInt = (float2) (1.0f/4294967296.0f, 1.0f/4294967296.0f);
	uint x = (*state).x * 17 + (*state).y * 13123;
	(*state).x = (x<<13) ^ x;
	(*state).y ^= (x<<7);

	uint2 tmp = (uint2)((x * (x * x * 15731 + 74323) + 871483),(x * (x * x * 13734 + 37828) + 234234));
	return convert_float2(tmp) * invMaxInt;
}

// Return random direction on hemiphere around normal.
// This function has: PDF = cos(theta) / pi
float4 rndCosWeightedHemisphereDir(float4 normal, uint2 *seed) {
	float2 rnd  = clRand(seed);

	// Generate point on disk
	float rd = sqrt(rnd.x);
	float phi = 2.0f*M_PI*rnd.y;

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * sqrt(1 - rnd.x));
}

// Return random cosine weighted direction in a cone centered at the normal
// proportional to a solid angle. This function has:
// PDF = cos(theta) /  pi * sin(theta_max)^2
float4 rndCosWeightedConeDir(float4 normal, float sinThetaMax, uint2 *seed){
	float2 rnd  = clRand(seed);

	float rd = sinThetaMax * sqrt(rnd.x);
	float phi = 2.0f*M_PI*rnd.y;
	float r2t = sqrt(1 - rnd.x*sinThetaMax*sinThetaMax);

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * r2t);
}

// Return random direction in a cone centered at the normal
// proportional to a solid angle. This function has:
// PDF = 1 / 2 * pi * (1 - cos(theta_max))
float4 rndConeDir(float4 normal, float cosThetaMax, uint2 *seed){
	float2 rnd  = clRand(seed);

	float rcd = 1.0f - rnd.x*(1.0f - cosThetaMax);
	float rd = sqrt(1.0f - rcd*rcd);
	float phi = 2.0f*M_PI*rnd.y;

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * rcd);
}

// Tracer implementation
// ---------------------

typedef struct {
	float4 position;
	float4 normal;
	float dist;
	uint material;
	int primitive;
} Hit;

float intersectPlane(const float4 rayOrigin, const float4 rayDir, const float3 planeNormal, const float planeDist){
	float denom = dot(planeNormal, rayDir.xyz);
	if (fabs(denom) < 1e-6f) {
		return FLT_MAX;
	}

	float t = -(dot(planeNormal, rayOrigin.xyz) - planeDist) / denom;
	return t > 0.0f ? t : FLT_MAX;
}

float intersectSphere(const float4 rayOrigin, const float4 rayDir, const float4 sphereOrigin, const float sphereRadius){
	float4 op = sphereOrigin - rayOrigin;
	float b = dot(op, rayDir);
	float discr = b*b - dot(op, op) + sphereRadius * sphereRadius;
	if (discr<0.0f){
		return FLT_MAX;
	}
	discr = sqrt(discr);
	float t = b - discr;
	if(t > SNAP_EPSILON) {
		return t;
	}
	t = b + discr;
	return t > SNAP_EPSILON ? t : FLT_MAX;
}

float intersectBox(const float4 rayOrigin, const float4 rayDir, const float4 boxMin, const float4 boxMax){
	float4 tmin = (boxMin - rayOrigin) / rayDir;
	float4 tmax = (boxMax - rayOrigin) / rayDir;

	// If tmin > tmax we need to swap them
	float4 rmin = fmin(tmin, tmax);
	float4 rmax = fmax(tmin, tmax);

	float minmax = fmin( fmin(rmax.x, rmax.y), rmax.z);
	float maxmin = fmax( fmax(rmin.x, rmin.y), rmin.z);
	return minmax >= maxmin && maxmin > SNAP_EPSILON ? maxmin : FLT_MAX;
}

float4 aabbNormal(const float4 hitPoint,  const float4 boxMin, const float4 boxMax){
	float4 rmin = fmin(boxMin, boxMax);
	float4 rmax = fmax(boxMin, boxMax);

	if (fabs(rmin.x - hitPoint.x) < SNAP_EPSILON){
		return (float4)(-1.0f, 0.0f, 0.0f, 0.0f);
	} else if (fabs(rmax.x - hitPoint.x) < SNAP_EPSILON){
		return (float4)(1.0f, 0.0f, 0.0f, 0.0f);
	} else if (fabs(rmin.y - hitPoint.y) < SNAP_EPSILON){
		return (float4)(0.0f, -1.0f, 0.0f,0.0f);
	} else if (fabs(rmax.y - hitPoint.y) < SNAP_EPSILON){
		return (float4)(0.0f, 1.0f, 0.0f,0.0f);
	} else if (fabs(rmin.z - hitPoint.z) < SNAP_EPSILON){
		return (float4)(0.0f, 0.0f, -1.0f,0.0f);
	}
	return (float4)(0.0f, 0.0f, 1.0f,0.0f);
}

float intersectTriangle(const float4 rayOrigin, const float4 rayDir, uint primIndex, image1d_t primitives, float4 *pointOut, float4 *normalOut, float2 *uvOut){
	// Calc intersection with triangle plane
	float4 normal = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,2) );
	float d = intersectPlane(rayOrigin, rayDir, normal.xyz, normal.w);
	if( d == FLT_MAX ){
		return d;
	}

	// Check if hit point is inside the triangle by computing the dot product with edge planes
	// to get barycentric coordinates.
	float4 edge;
	float3 point = (rayOrigin + rayDir * d).xyz;

	edge = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,3) );
	float kt1 =  dot(point, edge.xyz) - edge.w;
	if( kt1 < 0.0f ){
		return FLT_MAX;
	}
	edge = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,4) );
	float kt2 =  dot(point, edge.xyz) - edge.w;
	if( kt2 < 0.0f ){
		return FLT_MAX;
	}
	edge = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,5) );
	float kt3 =  dot(point, edge.xyz) - edge.w;
	if( kt3 < 0.0f ){
		return FLT_MAX;
	}

	*pointOut = (float4)(point, 0);
	*normalOut = (float4)(normal.xyz, 0);
	return d;
}

// Check for the closest intersection with scene primitives. If no interection
// is detected, hit->dist should be set to FLT_MAX
void getIntersection(const float4 rayOrigin, const float4 rayDir, uint numPrimitives, image1d_t primitives, Hit *hit){
	hit->dist = FLT_MAX;
	hit->primitive = -1;

	float dist;
	float4 normal;
	float4 hitPoint;
	float4 origin, extents;
	float2 uv;
	for(int primIndex=0;primIndex<numPrimitives;primIndex++){
		// Get primitive type and material index
		// x: primitive type
		// y: material index
		float4 primInfo = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,0));

		// Check for ray-primitive intersection
		switch(uint(primInfo.x)) {
			case PRIMITIVE_PLANE:
				// Get primitive origin and dimensions
				origin = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,1));
				extents = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,2));

				dist = intersectPlane(rayOrigin, rayDir, origin.xyz, extents.x);
				hitPoint = rayOrigin + rayDir * dist;
				normal = origin;
				break;
			case PRIMITIVE_SPHERE:
				// Get primitive origin and dimensions
				origin = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,1));
				extents = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,2));

				dist = intersectSphere(rayOrigin, rayDir, origin, extents.x);
				hitPoint = rayOrigin + rayDir * dist;
				normal = normalize(hitPoint - origin);
				break;
			case PRIMITIVE_BOX:
				// Get primitive origin and dimensions
				origin = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,1));
				extents = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,2));

				dist = intersectBox(rayOrigin, rayDir, origin, extents);
				hitPoint = rayOrigin + rayDir * dist;
				normal = aabbNormal(hitPoint, origin, extents);
				break;
			case PRIMITIVE_TRIANGE:
				dist = intersectTriangle(rayOrigin, rayDir, primIndex, primitives, &hitPoint, &normal, &uv);
				break;
		}

		if( dist < hit->dist ){
			hit->dist = dist;
			hit->position = hitPoint;
			hit->normal = normal;
			hit->material = uint(primInfo.y);
			hit->primitive = primIndex;
		}
	}
}

// Collect direct light at hit point.
float4 getDirectLight(Hit *hit, int numPrimitives, int numEmissiveIndices, image1d_t primitives, image1d_t materials, image1d_t emissiveIndices, uint2 *rndSeed){
	float4 light = 0.0f;
	float4 shadowRayOrigin = hit->position + hit->normal * NUDGE_EPSILON;
	Hit shadowHit;
	uint primIndex;
	for(int index=0;index<numEmissiveIndices;index++){

		// Fetch primitive index for emissive surface
		primIndex = read_imageui(emissiveIndices, dataSampler, index).x;

		// Get primitive type and material index
		// x: primitive type
		// y: material index
		float4 primInfo = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,0));

		// Get origin and extends. We will approximate the light with a sphere
		// positioned at the surface center having a radius equal to the greatest
		// distance to the primitive edges
		float4 origin = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,1));
		float4 extents = read_imagef(primitives, dataSampler, PRIM_OFFSET(primIndex,2));
		float4 center;
		float radius;
		switch(uint(primInfo.x)){
			case PRIMITIVE_PLANE:
				// Plane lights not supported
				continue;
			case PRIMITIVE_SPHERE:
				center = origin;
				radius = extents.x;
				break;
			case PRIMITIVE_BOX:
				center = (origin + extents) * 0.5f;
				float4 size = fabs(origin - extents) * 0.5f;
				radius = VEC3_MAX_COMPONENT(size);
				break;
			case PRIMITIVE_TRIANGE:
				center = origin;
				radius = extents.w;
				break;
			default:
				continue;
		}

		float4 lightDir = center - hit->position;

		// Early rejection for back-facing surfaces
		if(dot(lightDir, hit->normal) < 0.0f){
			continue;
		}

		// Treat the light as a sphere with radius the largest dimension; then
		// generate a lightDir vector to its center and a tangent vector so as to
		// form a right-angled triangle with base (light radius, light dir) and
		// hypotenuse the tangent vector. Then generate a random ray towards
		// the light proportional to the solid angle of the cone defined by
		// the triangle.
		float lightDirLen = length(lightDir);
		float tLen = hypot(lightDirLen, radius);
		lightDir = normalize(lightDir);
#ifdef CONE_LIGHT_SAMPLING
		float cosThetaMax = lightDirLen / tLen;
		float4 shadowDir = rndConeDir(lightDir, cosThetaMax, rndSeed);
		float pdf = dot(hit->normal, shadowDir) * 2.0f * (1.0f - cosThetaMax);
#endif
#ifdef COS_WEIGHTED_LIGHT_SAMPLING
		float sinThetaMax = radius / tLen;
		float4 shadowDir = rndCosWeightedConeDir(lightDir, sinThetaMax, rndSeed);
		float pdf = sinThetaMax * sinThetaMax;
#endif

		// Check line of sight; skip if we hit anything other than the target light
		getIntersection(shadowRayOrigin, shadowDir, numPrimitives, primitives, &shadowHit);
		if(shadowHit.primitive != primIndex){
			continue;
		}

		// Radiance = 1/pi * cos(theta) * emissive * PDF
		float4 emissive = read_imagef(materials, dataSampler, MAT_OFFSET(primInfo.y, 2));
		light += emissive * pdf;
	}
	return light;
}

// Trace a ray and return the gathered color.
float4 traceRay(float4 rayOrigin, float4 rayDir, int numPrimitives, int numEmissiveIndices, image1d_t primitives, image1d_t materials, image1d_t emissiveIndices, uint2 *rndSeed){
	Hit hit;
	float4 rCol = (float4)(0.0f);
	float4 mask = (float4)(1.0f);
	unsigned int bounce = 0;
	bool hitDiffuseObject = false;
	float nc, nt, eta, ddn;
	float4 nl, materialProps, diffuse;
	for(bounce=0;bounce<MAX_BOUNCES;bounce++){
		getIntersection(rayOrigin, rayDir, numPrimitives, primitives, &hit);

		// No hit
		if(hit.dist == FLT_MAX){
			if(bounce == 0){
				rCol = sceneBgColor;
			}
			break;
		}

		// Get material properties
		materialProps = read_imagef(materials, dataSampler, MAT_OFFSET(hit.material, 0));

		// If we hit a light just add its emissive property and stop
		if( materialProps.x == MATERIAL_EMISSIVE ){
			if ( !hitDiffuseObject ){
				rCol += mask * read_imagef(materials, dataSampler, MAT_OFFSET(hit.material, 2));
			}
			break;
		}

		// Fetch diffuse color
		diffuse = read_imagef(materials, dataSampler, MAT_OFFSET(hit.material, 1));

		// After some bounces apply a russian roulette to terminate long paths
		if( bounce > MIN_BOUNCES_TO_USE_RR ) {
			float maxComponent = VEC3_MAX_COMPONENT(diffuse);
			if( maxComponent == 0 || clRand(rndSeed).x > maxComponent ){
				break;
			}

			// Boost surviving paths by 1/rr_prob
			mask /= maxComponent;
		}

		// Handle material surface type	(BRDF)
		if( materialProps.x == MATERIAL_DIFFUSE ) {
			// Mask outgoing reflectance by material diffuse property
			mask *= diffuse;
			hitDiffuseObject = true;
			rCol += mask * getDirectLight(&hit, numPrimitives, numEmissiveIndices, primitives, materials, emissiveIndices, rndSeed);

			// We do importance sampling for diffuse rays
			rayOrigin = hit.position + hit.normal * NUDGE_EPSILON;
			rayDir = rndCosWeightedHemisphereDir(hit.normal, rndSeed);
		} else if ( materialProps.x == MATERIAL_SPECULAR){
			// Mask outgoing reflectance by material diffuse property
			mask *= diffuse;

			// Reflect ray around normal
			rayOrigin = hit.position + hit.normal * NUDGE_EPSILON;
			rayDir = normalize(-2.0f * dot(hit.normal, rayDir) * hit.normal + rayDir);

			// If a non-zero roughness value is specified, take a cone-sample instead
			if( materialProps.z > 0.0f){
				rayDir = rndConeDir(rayDir, 1.0f - materialProps.z, rndSeed);
			}
		} else if (materialProps.x == MATERIAL_REFRACTIVE){
			// Mask outgoing reflectance by material diffuse property
			mask *= diffuse;

			// Generate correctly oriented normal
			nl = dot(rayDir, hit.normal) < 0 ? hit.normal : -1.0f * hit.normal;
			ddn = dot(rayDir, nl);

			// ray going into object
			bool into = dot(nl, hit.normal) > 0.0f;
			if (into){
				nc = 1.0f; // air
				nt = materialProps.y;
			} else {
				nc = materialProps.y;
				nt = 1.0f; // air
			}
			eta = nc / nt;
			float cos2t = 1.0f - eta * eta * (1.0f - ddn*ddn);

			// Calc reflection ray
			float4 reflRay = normalize(rayDir - 2.0f * hit.normal * dot(hit.normal, rayDir));

			// If a non-zero roughness value is specified, take a cone-sample instead
			if( materialProps.z > 0.0f){
				reflRay = rndConeDir(reflRay, 1.0f - materialProps.z, rndSeed);
			}

			// Total internal reflection
			if( cos2t < 0.0f){
				// Reflect ray around normal
				rayOrigin = hit.position + nl * NUDGE_EPSILON;
				rayDir = reflRay;
			} else {
				// Compute transmission ray dir
				float4 transDir = normalize(rayDir * eta - hit.normal * ((into ? 1.0f : -1.0f) * (ddn*eta + sqrt(cos2t))));

				// Compute reflectance at normal angle (R0) and reflectance (re) using
				// Schlick's approximation:
				float R0 = (nt-nc)*(nt-nc) / (nt+nc)*(nt+nc);
				// c = cos of transmission ray and normal
				float c= 1.0f - (into ? -ddn : dot(transDir,hit.normal));
				// This is Schlick's approximation for reflectance at angle theta
				float re = R0 + (1.0f - R0) * c * c * c * c * c;
				float tr = 1.0f - re;
				float prob = 0.25f + 0.5f * re;
				// Calc reflection and transmission boost factor based on event probablilities
				float rp = re / prob;
				float tp = tr / (1.0f - prob);

				// Use RR to pick reflection or transmission
				float2 rnd = clRand(rndSeed);
				if( rnd.x < 0.25f) {
					mask *= rp;

					// Reflect ray around normal
					rayOrigin = hit.position + nl * SNAP_EPSILON;
					rayDir = reflRay;
				} else {
					mask *= tp;
					rayOrigin = hit.position - nl * SNAP_EPSILON;
					rayDir = transDir;
				}
			}
		}
	}

	return rCol;
}

// Emit the color of a pixel by tracing a ray through the scene.
__kernel void tracePixel(
		__global float4 *frameBuffer,
		__global float4 *frustrumCorners,
		image1d_t primitives,
		image1d_t materials,
		image1d_t emissiveIndices,
		const int numPrimitives,
		const int numEmissiveIndices,
		const float4 eyePos,
		const unsigned int blockY,
		const unsigned int samplesPerPixel,
		const float exposure,
		const int seed
		){
	// Get pixel coordinates
	unsigned int x = get_global_id(0);
	unsigned int y = get_global_id(1);
	if ( x > FRAME_W || y > FRAME_H ) {
		return;
	}

	// Setup seed for random numbers
	uint2 rndSeed = (uint2)(x * seed, y * seed);

	// Calculate texel coordinates [0,1] range
	float accumScaler = 1.0f / (float)samplesPerPixel;
	float4 accum = (float4)(0.0f,0.0f,0.0f,0.0f);

	for( uint sample=0;sample<samplesPerPixel;sample++){
		// Apply stratified sampling using a tent filter. This will wrap our
		// random numbers in the [-1, 1] range. X and Y point to the top corner
		// of the current texel so we need to add a bit of offset to get the coords
		// into the [-0.5, 1.5] range.
		float2 random = clRand(&rndSeed);
		float offX = random.x < 0.5f ? sqrt(2.0f * random.x) - 0.5f : 1.5f - sqrt(2.0f - 2.0f * random.x);
		float offY = random.y < 0.5f ? sqrt(2.0f * random.y) - 0.5f : 1.5f - sqrt(2.0f - 2.0f * random.y);
		float tx = ((float)x + offX) * TEXEL_STEP_X;
		float ty = ((float)y + offY) * TEXEL_STEP_Y;

		// Get ray direction using trilinear interpolation; trace ray and
		// add result to accumulation buffer
		float4 lVec = frustrumCorners[0] * (1 - ty) + frustrumCorners[2] * ty;
		float4 rVec = frustrumCorners[1] * (1 - ty) + frustrumCorners[3] * ty;
		accum += traceRay(eyePos, normalize(lVec * (1 - tx) + rVec * tx), numPrimitives, numEmissiveIndices, primitives, materials, emissiveIndices, &rndSeed);
	}

	// Average samples
	accum *= accumScaler;

	// Apply tone-mapping and gamma correction using:
	// 1 - exp(-hdrColor * exposure)) [tone mapping HDR -> LDR]
	// pow(ldr, 0.45)) [gamma correction]
	frameBuffer[y*FRAME_W + x] = pow(-expm1(-accum*exposure), 0.45f);
}
