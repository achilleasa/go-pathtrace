// Global parameters that will be set via a template during compilation time.
#define FRAME_W 512
#define FRAME_H 512
#define TEXEL_STEP_X 1.0f / 512.0f
#define TEXEL_STEP_Y 1.0f / 512.0f
#define MAX_TRACE_STEPS 128
#define NO_SURFACE_HIT -1

// Epsilon values
#define NUDGE_EPSILON 1.0e-2f
#define DIST_SNAP_EPSILON 1.0e-3f

// Vector helpers
#define VEC3_MAX_COMPONENT(v) max(v.x, max(v.y, v.z))
#define VEC3(x,y,z) (float4)(x,y,z,0.0f)
#define VEC3_ORIGIN VEC3(0,0,0)

// Supported surface types
#define SURFACE_DIFFUSE 0
#define SURFACE_SPECULAR 1
#define SURFACE_REFRACTIVE 2
#define SURFACE_LIGHT 65535

// DEBUGGING
#define DEBUG (get_global_id(0)==256 && get_global_id(1)==256)

// Distance estimator function generators
// --------------------------------------
#define PLANE_SD_FN(objIndex, origin, planeDims) float distToObj##objIndex( float4 point ){ \
	point -= origin; \
	float4 dims = normalize(planeDims); \
	return dot(point, dims); \
}
#define SPHERE_SD_FN(objIndex, origin, radius) float distToObj##objIndex( float4 point ){ \
	return length(point - origin) - radius; \
}
#define BOX_SD_FN(objIndex, origin, boxDims) float distToObj##objIndex( float4 point ){ \
	point -= origin; \
	float4 dims = boxDims; \
	float4 d = fabs(point) - (float4)(dims.xyz, point.w); \
	return fmin(VEC3_MAX_COMPONENT(d), 0.0f) + length(fmax(d, 0.0f)); \
}
#define TORUS_SD_FN(objIndex, origin, torusDims) float distToObj##objIndex( float4 point ){ \
	point -= origin; \
	float2 dims = torusDims; \
	return length((float2)(length(point.xz) - dims.x, point.y)) - dims.y; \
}

// Normal estimator generators
#define OBJECT_NORMAL_AT(objIndex, point) \
	normalize( \
		(float4)( \
			distToObj##objIndex(point + VEC3(NUDGE_EPSILON, 0,0)) - distToObj##objIndex(point - VEC3(NUDGE_EPSILON, 0,0)), \
			distToObj##objIndex(point + VEC3(0, NUDGE_EPSILON,0)) - distToObj##objIndex(point - VEC3(0, NUDGE_EPSILON,0)), \
			distToObj##objIndex(point + VEC3(0, 0, NUDGE_EPSILON)) - distToObj##objIndex(point - VEC3(0, 0, NUDGE_EPSILON)), \
			0.0f \
		) \
	)

// Tracer implementation
// ---------------------

typedef struct {
	float4 position;
	float4 normal;
	float distFromOrigin;
	int objIndex;
	int matIndex;
} Hit;

typedef struct {
	unsigned int type;
	float4 diffuse;
	float4 emissive;
} Material;

// Material definitions
// The following code will be autogenerated by the scene processor
// ------------------
__constant float4 sceneBgColor = (float4)(0);

__constant Material SceneMaterial[] = {
	{SURFACE_LIGHT, VEC3(0,0,0), VEC3(60,60,60)},
	{SURFACE_DIFFUSE, VEC3(0.75, 0.25, 0.25)},
	{SURFACE_DIFFUSE, VEC3(0.25, 0.25, 0.75)},
	{SURFACE_DIFFUSE, VEC3(0.75, 0.75, 0.75)},
	{SURFACE_SPECULAR, VEC3(0.999, 0.999, 0.999)},
	{SURFACE_REFRACTIVE, VEC3(0.999, 0.999, 0.999)}
};

// Object definitions
// The following code will be autogenerated by the scene processor
// ------------------

// Light
SPHERE_SD_FN(0, VEC3(0, 1.5, 0), 0.1f)
// Left wall
BOX_SD_FN(1, VEC3(-2,0,0), VEC3(0.1, 2, 2))
// Right wall
BOX_SD_FN(2, VEC3(2,0,0), VEC3(0.1, 2, 2))
// Top wall
BOX_SD_FN(3, VEC3(0,2,0), VEC3(2, 0.1, 2))
// Bottom wall
BOX_SD_FN(4, VEC3(0,-2,0), VEC3(2, 0.1, 2))
// Back wall
BOX_SD_FN(5, VEC3(0,0,-2), VEC3(2, 2, 0.1))
// Mirror ball
SPHERE_SD_FN(6, VEC3(-1.0, -1.4, -1.0), 0.5)
// Glass ball
SPHERE_SD_FN(7, VEC3(1.4, -1.4, -0.5), 0.5)

// Estimate normal at intersection point
void getNormal(Hit *hit){
	// The following code will be autogenerated by the scene processor
	if( hit->objIndex == 0 ){
		hit->normal = OBJECT_NORMAL_AT(0, hit->position);
	} else if( hit->objIndex == 1 ){
		hit->normal = OBJECT_NORMAL_AT(1, hit->position);
	} else if( hit->objIndex == 2 ){
		hit->normal = OBJECT_NORMAL_AT(2, hit->position);
	} else if( hit->objIndex == 3 ){
		hit->normal = OBJECT_NORMAL_AT(3, hit->position);
	} else if( hit->objIndex == 4 ){
		hit->normal = OBJECT_NORMAL_AT(4, hit->position);
	} else if( hit->objIndex == 5 ){
		hit->normal = OBJECT_NORMAL_AT(5, hit->position);
	} else if( hit->objIndex == 6 ){
		hit->normal = OBJECT_NORMAL_AT(6, hit->position);
	} else if( hit->objIndex == 7 ){
		hit->normal = OBJECT_NORMAL_AT(7, hit->position);
	}
}

// Estimate distance to nearest object
void intersectWorld(const float4 rayOrigin, const float4 rayDir, const float minDist, const float maxDist, Hit *hit){
	hit->objIndex = NO_SURFACE_HIT;
	hit->matIndex = NO_SURFACE_HIT;

	float4 point;
	float curDist = minDist;
	float objDist, nearestDist;
	int nearestObj = -1;
	int nearestMat = -1;
	for(unsigned int step=0;step<MAX_TRACE_STEPS;step++){
		point = rayOrigin + rayDir * curDist;

		// Find nearest object/dist to point
		// The following code will be autogenerated by the scene processor
		nearestDist = FLT_MAX;
		objDist = distToObj0(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 0;
			nearestMat = 0;
		}
		objDist = distToObj1(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 1;
			nearestMat = 1;
		}
		objDist = distToObj2(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 2;
			nearestMat = 2;
		}
		objDist = distToObj3(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 3;
			nearestMat = 3;
		}
		objDist = distToObj4(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 4;
			nearestMat = 3;
		}
		objDist = distToObj5(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 5;
			nearestMat = 3;
		}
		objDist = distToObj6(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 6;
			nearestMat = 4;
		}
		objDist = distToObj7(point);
		if(objDist < nearestDist){
			nearestDist = objDist;
			nearestObj = 7;
			nearestMat = 5;
		}

		// If we are inside an object nearestDist will be < 0
		nearestDist = fabs(nearestDist);

		curDist += nearestDist;
		if(curDist > maxDist){
			return;
		}

		// We are close enough to the object to register a hit
		if(nearestDist < DIST_SNAP_EPSILON){
			hit->position = point;
			hit->distFromOrigin = curDist;
			hit->objIndex = nearestObj;
			hit->matIndex = nearestMat;
			return;
		}
	}
}

// Trace a ray and return the gathered color.
float4 traceRay(float4 rayOrigin, float4 rayDir){
	Hit hit;
	float4 rCol;
	unsigned int bounce = 0;
	while( true ){
		intersectWorld(rayOrigin, rayDir, NUDGE_EPSILON, FLT_MAX, &hit);

		// No hit
		if(hit.objIndex == NO_SURFACE_HIT){
			if(bounce == 0){
				rCol = sceneBgColor;
			}
			break;
		}

		// Get normal at hit point
		getNormal(&hit);

		// For now just output the diffuse (or emissive for lights)
		rCol = max(SceneMaterial[hit.matIndex].diffuse, SceneMaterial[hit.matIndex].emissive);
		break;
	}

	return rCol;
}

// Emit the color of a pixel by tracing a ray through the scene.
__kernel void tracePixel(
		__global float4 *frameBuffer,
		__global float4 *frustrumCorners,
		const float4 eyePos,
		const unsigned int blockY,
		const unsigned int samplesPerPixel,
		const float exposure
		){
	// Get pixel coordinates
	unsigned int x = get_global_id(0);
	unsigned int y = get_global_id(1);
	if ( x > FRAME_W || y > FRAME_H ) {
		return;
	}

	// Calculate texel coordinates [0,1] range
	float tx = (float)(x) * TEXEL_STEP_X;
	float ty = (float)(y) * TEXEL_STEP_Y;
	float accumScaler = 1.0f / (float)samplesPerPixel;
	float4 accum = (float4)(0,0,0,0);

	for( uint sample=0;sample<samplesPerPixel;sample++){
		// Get ray direction using trilinear interpolation; trace ray and
		// add result to accumulation buffer
		float4 lVec = frustrumCorners[0] * (1 - ty) + frustrumCorners[2] * ty;
		float4 rVec = frustrumCorners[1] * (1 - ty) + frustrumCorners[3] * ty;
		accum += traceRay(eyePos, normalize(lVec * (1 - tx) + rVec * tx));
	}

	// Average samples
	accum *= accumScaler;

	// Apply tone-mapping and gamma correction using:
	// 1 - exp(-hdrColor * exposure)) [tone mapping HDR -> LDR]
	// pow(ldr, 0.45)) [gamma correction]
	frameBuffer[y*FRAME_W + x] = pow(-expm1(-accum*exposure), 0.45f);
}
