// Global parameters that will be set via a template during compilation time.
#ifndef M_PI
#define M_PI 3.14159265358979323846f
#endif
#define FRAME_W 512
#define FRAME_H 512
#define TEXEL_STEP_X 1.0f / 512.0f
#define TEXEL_STEP_Y 1.0f / 512.0f

#define DEBUG (get_global_id(0) == 420 && get_global_id(1) == 400)

// Limits
#define MAX_BOUNCES 4 // iris pro compilation runs out of memory if set to > 5
#define MIN_BOUNCES_TO_USE_RR 3

// Epsilon values
#define NUDGE_EPSILON 1.0e-3f

// Vector helpers
#define VEC3_MAX_COMPONENT(v) max(v.x, max(v.y, v.z))
#define VEC1(x) (float4)(x, 0.0f, 0.0f, 0.0f)
#define VEC2(x,y) (float4)(x, y, 0.0f, 0.0f)
#define VEC3(x,y,z) (float4)(x,y,z,0.0f)
#define VEC4(x,y,z,w) (float4)(x,y,z,w)
#define ORIGIN(v) VEC3(v,v,v)

// Supported material types
#define MATERIAL_DIFFUSE 0.0f
#define MATERIAL_SPECULAR 1.0f
#define MATERIAL_REFRACTIVE 2.0f
#define MATERIAL_EMISSIVE 65535.0f

// Supported primitive types
#define PRIMITIVE_PLANE 0
#define PRIMITIVE_SPHERE 1
#define PRIMITIVE_BOX 2
#define PRIMITIVE_TORUS 3

// Packed data sampler
const sampler_t dataSampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;

// Data offset calculator shortcuts:
// packed primitives and materials are 48 bytes each and our images are
// RGBA buffers where each component is 4 bytes long (CL_FLOAT). So each
// item is encoded using 48 / 16 = 3 pixels.
#define DATA_OFFSET(itemIndex, field) (int)(itemIndex * 3 + field)
#define DATA_OFFSET_F(itemIndex, field) (float)(itemIndex * 3 + field)

#define DEBUG (get_global_id(0) == 0 && get_global_id(1) == 0)

// -----------------------
// Object and material definitions
// The following code will be autogenerated by the scene processor
// ------------------
__constant float4 sceneBgColor = (float4)(0.0f);

// -----------------------
// Random number and direction generators
// -----------------------
float2 clRand(uint2 *state)
{
    const float2 invMaxInt = (float2) (1.0f/4294967296.0f, 1.0f/4294967296.0f);
    uint x = (*state).x * 17 + (*state).y * 13123;
    (*state).x = (x<<13) ^ x;
    (*state).y ^= (x<<7);

    uint2 tmp = (uint2)
    (
		(x * (x * x * 15731 + 74323) + 871483),
		(x * (x * x * 13734 + 37828) + 234234)
	);

    return convert_float2(tmp) * invMaxInt;
}

// Return random direction on hemiphere around normal.
// This function has: PDF = cos(theta) / pi
float4 rndCosWeightedHemisphereDir(float4 normal, uint2 *seed) {
	float2 rnd  = clRand(seed);

	// Generate point on disk
	float rd = sqrt(rnd.x);
	float phi = 2.0f*M_PI*rnd.y;

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * sqrt(1 - rnd.x));
}

// Return random cosine weighted direction in a cone centered at the normal
// proportional to a solid angle. This function has:
// PDF = cos(theta) /  pi * sin(theta_max)^2
float4 rndCosWeigthedConeDir(float4 normal, float sinThetaMax, uint2 *seed){
	float2 rnd  = clRand(seed);

	float rd = sinThetaMax * sqrt(rnd.x);
	float phi = 2.0f*M_PI*rnd.y;
	float r2t = sqrt(1 - rnd.x*sinThetaMax*sinThetaMax);

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * r2t);
}

// Return random direction in a cone centered at the normal
// proportional to a solid angle. This function has:
// PDF = 1 / 2 * pi * (1 - cos(theta_max))
float4 rndConeDir(float4 normal, float cosThetaMax, uint2 *seed){
	float2 rnd  = clRand(seed);

	float rcd = 1.0f - rnd.x*(1.0f - cosThetaMax);
	float rd = sqrt(1.0f - rcd*rcd);
	float phi = 2.0f*M_PI*rnd.y;

	// Generate tangent, bi-tangent vectors
	float4 u = normalize(cross((fabs(normal.x) > .1f ? (float4)(0.0f, 1.0f, 0.0f, 0.0f) : (float4)(1.0f, 0.0f, 0.0f, 0.0f)), normal));
	float4 v = cross(normal,u);

	// Project disk point to unit hemisphere and rotate so that the normal points up
	return normalize(u * rd * cos(phi) + v * rd * sin(phi) + normal * rcd);
}

// Tracer implementation
// ---------------------

typedef struct {
	float4 position;
	float4 normal;
	float dist;
	uint material;
} Hit;

float intersectPlane(const float4 rayOrigin, const float4 rayDir, const float4 planeNormal, const float planeDist){
    float denom = dot(planeNormal, rayDir); 
    if (denom < 1e-6) { 
		return FLT_MAX;
	}

    float t = (dot(planeNormal, rayOrigin) + planeDist) / denom;
	return t > 0 ? t : FLT_MAX;
}

float intersectSphere(const float4 rayOrigin, const float4 rayDir, const float4 sphereOrigin, const float sphereRadius){
	float4 op = sphereOrigin - rayOrigin;
	float epsilon = 0.01f;
	float b = dot(op, rayDir);
	float discr = b*b - dot(op, op) + sphereRadius * sphereRadius;
	if (discr<0){
		return FLT_MAX;
	}
	discr = sqrt(discr);
	float t = b - discr;
	if(t > epsilon) {
		return t;
	}
	t = b + discr;
	return t > epsilon ? t : FLT_MAX;
}

// Check for the closest intersection with scene primitives. If no interection
// is detected, hit->dist should be set to FLT_MAX
void getIntersection(const float4 rayOrigin, const float4 rayDir, uint numPrimitives, image1d_t packedPrimitives, Hit *hit){
	hit->dist = FLT_MAX;

	float dist;
	float4 normal;
	float4 hitPoint;
	for(uint primIndex=0;primIndex<numPrimitives;primIndex++){
		// Get primitive type and material index
		// x: primitive type
		// y: material index
		uint4 primInfo = read_imageui(packedPrimitives, dataSampler, DATA_OFFSET(primIndex,0));

		// Get primitive origin and dimensions
		float4 origin = read_imagef(packedPrimitives, dataSampler, DATA_OFFSET_F(primIndex,1));
		float4 dims = read_imagef(packedPrimitives, dataSampler, DATA_OFFSET_F(primIndex,2));

		// Check for ray-primitive intersection
		switch(primInfo.x) {
			case PRIMITIVE_PLANE:
				dist = intersectPlane(rayOrigin, rayDir, origin, dims.x);
				hitPoint = rayOrigin + rayDir * dist;
				normal = normalize(dims.xyz);
			case PRIMITIVE_SPHERE:
				dist = intersectSphere(rayOrigin, rayDir, origin, dims.x);
				hitPoint = rayOrigin + rayDir * dist;
				normal = normalize(hitPoint - origin);
			break;
		}

		if( dist < hit->dist ){
			hit->dist = dist;
			hit->position = hitPoint;
			hit->normal = normal;
			hit->material = primInfo.y;
		}
	}
}

// Collect direct light at hit point.
float4 getDirectLight(Hit *hit, uint2 *rndSeed){
	return 1.0f;
	/*
	float4 light = 0.0f;
	Hit shadowHit;
	__constant Material *material;
	unsigned int objIndex;
	unsigned int numObjects = (uint)(sizeof(SceneObject) / sizeof(Object));

	for(objIndex=0;objIndex<numObjects; objIndex++){
		material = &SceneMaterial[SceneObject[objIndex].material];
		if( material->type != MATERIAL_LIGHT) {
			continue;
		}

		float4 lightDir = SceneObject[objIndex].origin - hit->position;

		// Early rejection for back-facing surfaces
		if(dot(lightDir, hit->normal) < 0){
			continue;
		}

		// Treat the light as a sphere with radius the largest dimension; then
		// generate a lightDir vector to its center and a tangent vector so as to
		// form a right-angled triangle with base (light radius, light dir) and
		// hypotenuse the tangent vector. Then generate a random ray towards
		// the light proportional to the solid angle of the cone defined by
		// the triangle.
		float lightDirLen = length(lightDir);
		float radius = SceneObject[objIndex].params.x;
		float tLen = sqrt(lightDirLen*lightDirLen + radius*radius);
		float cosThetaMax = lightDirLen / tLen;
		lightDir = normalize(lightDir);
		float4 shadowDir = rndConeDir(lightDir, cosThetaMax, rndSeed);

		// Check line of sight; if we hit anything other than the target or nothing reject light
		intersectWorld(hit->position, shadowDir, NUDGE_EPSILON, lightDirLen, &shadowHit);
		if(shadowHit.objIndex != objIndex && shadowHit.objIndex != NO_MATERIAL_HIT){
			continue;
		}

		// Radiance = 1/pi * cos(theta) * emissive * PDF
		light += material->emissive * dot(hit->normal, shadowDir) * 2.0f * (1.0f - cosThetaMax);

	}
	return light;
	*/
}

// Trace a ray and return the gathered color.
float4 traceRay(float4 rayOrigin, float4 rayDir, uint numPrimitives, image1d_t packedPrimitives, image1d_t packedMaterials, uint2 *rndSeed){
	Hit hit;
	float4 rCol = (float4)(0.0f);
	float4 mask = (float4)(1.0f);
	unsigned int bounce = 0;
	bool hitDiffuseObject = false;
	float nc, nt, eta, ddn;
	float4 nl, materialProps, diffuse;
	for(bounce=0;bounce<MAX_BOUNCES;bounce++){
		getIntersection(rayOrigin, rayDir, numPrimitives, packedPrimitives, &hit);

		// No hit
		if(hit.dist == FLT_MAX){
			if(bounce == 0){
				rCol = sceneBgColor;
			}
			break;
		}

		// Get material properties
		materialProps = read_imagef(packedMaterials, dataSampler, DATA_OFFSET_F(hit.material, 0));

		// If we hit a light just add its emissive property and stop
		if( materialProps.x == MATERIAL_EMISSIVE ){
			if ( !hitDiffuseObject ){
				rCol += mask * read_imagef(packedMaterials, dataSampler, DATA_OFFSET_F(hit.material, 2));
			}
			break;
		}

		// Fetch diffuse color
		diffuse = read_imagef(packedMaterials, dataSampler, DATA_OFFSET_F(hit.material, 1));

		// After some bounces apply a russian roulette to terminate long paths
		if( bounce > MIN_BOUNCES_TO_USE_RR ) {
			float maxComponent = VEC3_MAX_COMPONENT(diffuse);
			if( maxComponent == 0 || clRand(rndSeed).x > maxComponent ){
				break;
			}

			// Boost surviving paths by 1/rr_prob
			mask /= maxComponent;
		}

		// Next bounce starts at hit point with a small nudge along the normal
		// to prevent self-intersection
		rayOrigin = hit.position + hit.normal * NUDGE_EPSILON;

		// Handle material surface type	(BRDF)
		if( materialProps.x == MATERIAL_DIFFUSE ) {
			// Mask outgoing reflectance by material diffuse property
			mask *= diffuse; 
			hitDiffuseObject = true;
			rCol += mask * getDirectLight(&hit, rndSeed);

			// We do importance sampling for diffuse rays
			rayDir = rndCosWeightedHemisphereDir(hit.normal, rndSeed);
		} else if ( materialProps.x == MATERIAL_SPECULAR){
			// Mask outgoing reflectance by material diffuse property
			mask *= diffuse;

			// Reflect ray around normal
			rayDir = normalize(-2.0f * dot(hit.normal, rayDir) * hit.normal + rayDir);
		} else if (materialProps.x == MATERIAL_REFRACTIVE){
			bool insideObject = dot(rayDir, hit.normal) > 0.0f;
			if (insideObject ){
				nl = hit.normal * -1.0f;
				nc = materialProps.y;
				nt = 1.0f; // air
			} else {
				nl = hit.normal;
				nc = 1.0f; // air
				nt = materialProps.y;
			}
			eta = nt / nc;
			ddn = dot(rayDir, nl);
			float cos2t = 1.0f - eta * eta * (1.0f - ddn*ddn);

			// Total internal reflection
			if( cos2t < 0.0f){
				// Reflect ray around normal
				rayDir = normalize(-2.0f * dot(hit.normal, rayDir) * hit.normal + rayDir);
			} else {

				// Compute transmission ray dir
				float4 transDir = rayDir * eta;
				transDir -= hit.normal * ((insideObject ? 1.0f : -1.0f) * (ddn*eta + sqrt(cos2t)));
				transDir = normalize(transDir);

				// Compute reflectance at normal angle (R0) and reflectance (re) using
				// Schlick's approximation:
				float R0 = (nt-nc)*(nt-nc) / (nt+nc)*(nt+nc);
				// c = cos of transmission ray and normal
				float c= 1.0f - (insideObject ? -ddn : dot(transDir,hit.normal));
				// This is Schlick's approximation for reflectance at angle theta
				float re = R0 + (1.0f - R0) * c * c * c * c * c;
				float tr = 1.0f - re;
				float prob = 0.25f + 0.5f * re;
				// Calc reflection and transmission boost factor based on event probablilities
				float rp = re / prob;
				float tp = tr / (1.0f - prob);

				// Use RR to pick reflection or transmission
				float2 rnd = clRand(rndSeed);
				if( rnd.x < 0.25f) {
					mask *= rp;

					// Reflect ray around normal
					rayDir = normalize(-2.0f * dot(hit.normal, rayDir) * hit.normal + rayDir);
				} else {
					mask *= tp;
					rayDir = transDir;
				}
			}
		}
	}

	return rCol;
}

// Emit the color of a pixel by tracing a ray through the scene.
__kernel void tracePixel(
		__global float4 *frameBuffer,
		__global float4 *frustrumCorners,
		image1d_t packedPrimitives,
		image1d_t packedMaterials,
		const unsigned int numPrimitives,
		const float4 eyePos,
		const unsigned int blockY,
		const unsigned int samplesPerPixel,
		const float exposure,
		const int seed
		){
	// Get pixel coordinates
	unsigned int x = get_global_id(0);
	unsigned int y = get_global_id(1);
	if ( x > FRAME_W || y > FRAME_H ) {
		return;
	}

	// Setup seed for random numbers
	uint2 rndSeed = (uint2)(x * seed, y * seed);

	// Calculate texel coordinates [0,1] range
	float accumScaler = 1.0f / (float)samplesPerPixel;
	float4 accum = (float4)(0.0f,0.0f,0.0f,0.0f);

	for( uint sample=0;sample<samplesPerPixel;sample++){
		// Apply stratified sampling using a tent filter. This will wrap our
		// random numbers in the [-1, 1] range. X and Y point to the top corner
		// of the current texel so we need to add a bit of offset to get the coords
		// into the [-0.5, 1.5] range.
		float2 random = clRand(&rndSeed);
		float offX = random.x < 0.5f ? sqrt(2.0f * random.x) - 0.5f : 1.5f - sqrt(2.0f - 2.0f * random.x);
		float offY = random.y < 0.5f ? sqrt(2.0f * random.y) - 0.5f : 1.5f - sqrt(2.0f - 2.0f * random.y);
		float tx = ((float)x + offX) * TEXEL_STEP_X;
		float ty = ((float)y + offY) * TEXEL_STEP_Y;

		// Get ray direction using trilinear interpolation; trace ray and
		// add result to accumulation buffer
		float4 lVec = frustrumCorners[0] * (1 - ty) + frustrumCorners[2] * ty;
		float4 rVec = frustrumCorners[1] * (1 - ty) + frustrumCorners[3] * ty;
		accum += traceRay(eyePos, normalize(lVec * (1 - tx) + rVec * tx), numPrimitives, packedPrimitives, packedMaterials, &rndSeed);
	}

	// Average samples
	accum *= accumScaler;

	// Apply tone-mapping and gamma correction using:
	// 1 - exp(-hdrColor * exposure)) [tone mapping HDR -> LDR]
	// pow(ldr, 0.45)) [gamma correction]
	frameBuffer[y*FRAME_W + x] = pow(-expm1(-accum*exposure), 0.45f);
}
